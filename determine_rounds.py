#!/usr/bin/python3
from math import log2, ceil
import argparse

parser = argparse.ArgumentParser(
            description='''Calculate the number of rounds for LowMC in dependence
                           on a given parameter set.''')
parser.add_argument('n', type=int,
                    help='specifies the block size')
parser.add_argument('m', type=int,
                    help='specifies the number of Sboxes per nonlinear layer')
parser.add_argument('d', type=int,
                    help='specifies the data security')
parser.add_argument('k', type=int,
                    help='specifies the key size')
group = parser.add_mutually_exclusive_group()
group.add_argument('-v', '--verbose', action='store_true',
                   help='print additional information')
group.add_argument('-q', '--quiet', action='store_true',
                   help='print only the total number of rounds')

args = parser.parse_args()

#Definitions
charbound = 2**(-100) # Defines what to consider a negligible probability

def choose(z,n):
    '''Calculates the binomial coefficients of z and n.'''
    p = 1
    q = 1
    for i in range(n):
        p *= z - i
        q *= i+1
    return p//q

def degterms(n, deg):
    '''Calculate the number of possible terms of degree at most 'deg' in
       n variables.'''
    tms = 0
    for d in range(deg + 1):
        tms += choose(n, d)
    return tms

def V(m,l,i):
    '''Number of vectors that activate i out
       of m Sboxes with identity part length l'''
    return choose(m,i) * 7**i * 2**l

def prob_actiboxes(m,l,r,d):
    '''Returns an upper bound for the probability that
       there exist a characteristic over r rounds that
       activates at most d Sboxes. m is the number of
       Sboxes per Sbox layer and l is the length of
       the identity part.'''
    probs = [V(m,l,i)*4**i for i in range(d+1)]
    #Probs counts the number of possible characteristics for each
    #allowed number of activated Sboxes.
    #Note: each input difference has 4 possible output differences
    for rnd in range(2, r+1):
        newprobs = [0 for i in range(d+1)]
        for i in range(d+1):
            for j in range(d-i+1):
                newprobs[i+j] += probs[i] * V(m,l,j) * 4**j
        probs = newprobs
    #Count the total number of valid characteristics
    total = 0
    for chars in probs:
        total += chars
    #Return the bound
    tmp = max(((2**(3*m+l)-1)**(r-1) // total), 1)
    if tmp >= 2**1024:
        return 0.0
    else:
        return 1.0/tmp
#    return 1.0 / max(((2**(3*m+l)-1)**(r-1) // total), 1)

def order(m,n,r):
    '''Calculates an upper bound for the algebraic degree
       after r rounds. m is the number of Sboxes per Sbox
       layer, n ist the block size.'''
    deg = 1;
    for i in range(r):
        deg = min(2*deg, m+deg, (n+deg)//2)    
    return deg

def influencerounds(m,n):
    '''Estimate number of rounds for one bit to influence all others'''
    return ceil(n/(7/8*m*3))

def interpolationterms(n,m,k,rounds):
    '''Estimate the number of different terms in the key bits that appear
       in an interpolation attack on the last 'rounds' rounds '''
    U = [0 for _ in range(n+1)]
    # U[d] will hold an estimation of the number of terms with degree d
    # After 1 round
    U[0] = 1
    U[1] = n
    U[2] = 3*m
    # For each additional round
    for r in range(1, rounds):
        # Store the new number of terms in newU
        newU = []
        # The number of constant terms and linear terms is always 1 and n
        newU.append(1)
        newU.append(n)
        # The terms of higher degree are generated by multiplying terms
        # of lower degree
        for d in range(2,n+1):
            tmp = 0
            for i in range(0,d//2+1):
                tmp += U[i]*U[d-i]
            newU.append( min(tmp, choose(n,d)) )
            # The number of terms of degree d is always upper bounded by
            # choose(n, d)
        U = newU
    # To estimate the number of terms we combined the estimate
    # for the number of terms in the ciphertext bits with the number
    # of terms possible for the key bits.
    # As a term of degree d in the ciphertext bits can only have a 
    # coefficient of degree 2**rounds-d in the key bits, we have the following
    tms = 0
    for d in range(2**rounds + 1):
#        print(d, U[d], degterms(k, 2**rounds - d))
        tms += min(U[d], degterms(k, 2**rounds - d) )
    return tms

#Set the parameters
m = args.m
n = args.n
dat = args.d
k = args.k
l = n - 3*m

#Check validity of parameters
if n < dat or m*3 > n or any(x < 1 for x in {m,n,dat}):
    print("Invalid parameter set")
    exit()



#Calculate bound for differentials, boomerangs and high-order
rstat = 0
rbmrng = 0
rdeg = 0
rinfl = 0
# Bounds for normal differentials
for r in range(1, 100000):
    prob = prob_actiboxes(m,n-3*m, r, dat//2)
    if prob <= charbound:
        rstat = r
        break
# Bounds for boomerangs
for r0 in range(1, 100000):
    for r1 in range(r0,r0+2):
        #Note: Boomerang probability for a sub-characteristic
        #      has to be a fourth of the normal bound
        prob = []
        for d in range(dat//4+1):
            p0 = prob_actiboxes(m,n-3*m, r0, d)
            p1 = prob_actiboxes(m,n-3*m, r1, dat//4-d)
            prob.append( min(p0,p1) )
        if max(prob) <= charbound:
            rbmrng = r0 + r1
            break
    else:
        continue
    break
    
# Bounds for degree
for r in range(1, 100000):
    if order(m,n,r) >= dat-1:
        rdeg = r
        break
# Calculate influence rounds
rinfl =  influencerounds(m,n)

# Calculate interpolation rounds
rinterpol = 0
for r in range(100000):
    if log2(interpolationterms(n,m,k,r)) >= k/2.3:
        rinterpol = r
        break

#Calculate outer rounds
router = rinterpol

#Calculate total number of rounds
rtot = max(rstat, rbmrng, rdeg+rinfl) + router


if args.quiet:
    print(rtot)
else:
    if args.verbose:
        print('Block size n:   ', n)
        print('# of Sboxes m:  ', m)
        print('Data security d:', dat)
        print('Negligible probability:', charbound)
        print('----------')
    print('rstat:         {:>4}'.format(rstat), end='')
    print('\t\tANDdepth: {:>5}'.format(rtot) )
    print('rbmrng:        {:>4}'.format(rbmrng), end='')
    print('\t\tANDs:     {:>5}'.format(rtot*3*m) )
    print('rinfl:         {:>4}'.format(rinfl), end='')
    print('\t\tANDs/bit: {:>5}'.format(round(rtot*3*m/n,2)) )
    print('rdeg:          {:>4}'.format(rdeg), end='')
    print()
    print('rdeg + rinfl:  {:>4}'.format(rdeg+rinfl), end='')
    print()
    print('rinterpol:     {:>4}'.format(rinterpol), end='')
    print()
    print('router:        {:>4}'.format(router), end='')
    print()
    print('-----------------')
    print('total:         {:>4}'.format(rtot), sep='')
    print()

